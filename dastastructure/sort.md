排序概述

## 排序稳定性

排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。

即：如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。

## 什么时候必须要求使用稳定排序呢

当现实应用中排序的需求需要区别先后顺序的时候就必须用到稳定排序。

如发奖学金，排在前三个的分别获一、二、三等奖，结果一排序把原来并列第二名的排成第三名，估计不会乐意。

## 分类

不稳定的排序: 选择排序、快速排序、希尔排序、堆排序。

稳定排序：冒泡排序、插入排序、归并排序、基数排序。

## 算法复杂度

![](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)




# 冒泡排序

相邻的两个元素进行比较，如果符合条件就换位。

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

### 算法描述

（1）比较相邻的元素。如果第一个比第二个大，就交换它们两个。

（2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数。

（3）针对所有的元素重复以上的步骤，除了最后一个。

（4）重复步骤1~3，直到排序完成。

### 动图演示

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)

注：这样第一轮，最大的数会在最后面，长度在依次递减 。

### 代码演示

```java
// 冒泡排序
public int[] bubbleSort(int[] arr) {
    int len = arr.length;
    for (int i = 0; i < len - 1; i++) { // 因为最后一个元素的排序没有必要
        // 排序之后，之前未排序的数据，最大的数会在最后面，长度在依次递减 
        for (int j = 0; j < len - 1 - i; j++) { 
            if (arr[j] > arr[j+1]) {        // 相邻元素两两对比
                int temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
```



# 选择排序

第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。

待排序的数据：3	1	4	2	7 	5

![](images/selectsort.png)

```java
// 选择排序
public int[] selectsort(int[] arr) {
    for(int x=0;x<arr.length-1;x++)  //最后一个数不用在自己和自己进行比较了，n-1轮
    {
        for(int y=x+1;y<arr.length;y++)
        {
            if(arr[x]>arr[y])
            {
                int temp=arr[x];
                arr[x]=arr[y];
                arr[y]=temp;                
            }
        }
    }
    return arr;
}
```









