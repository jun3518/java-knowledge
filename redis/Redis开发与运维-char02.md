## 2.1 预备

### 2.1.2 数据和内部编码

type命令实际返回的就是当前键的数据结构类型，它们分别是：string（字符串）、hash（哈希）、list（表）、set（集合）、zset（有序集合），但这些只是Redis对外的数据结构。实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的内部编码。

![](images/Redis的5种数据结构.png)

![](images/Redis数据结构和内部编码.png)

Redis这样设计有两个好处：第一，可以改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令。

### 2.1.3 单线程架构

Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。

因为Redis是单线程来处理命令的，所以一条命令从客户端达到服务端不会立刻被执行，所有命令都会进入一个队列中，然后逐个被执行。

注：Redis可以确定不会有两条命令被同时执行。

![](images/Redis客户端与服务端请求过程.png)

![](images/所有命令在一个队列里排队等待被执行.png)

![](images/不存在多个命令被同时执行的情况.png)

#### 为什么单线程还能这么快？

（1）纯内存访问，Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，这是Redis达到每秒万级别访问的重要基础。

（2）非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。

![](images/Redis使用IO多路复用和自身事件模型.png)

（3）单线程避免了线程切换和竞态产生的消耗。

#### 单线程能带来几个好处：

（1）单线程可以简化数据结构和算法的实现。

（2）单线程避免了线程切换和竞态产生的消耗（锁和线程切换通常是性能杀手）。

但是单线程会有一个问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞，对于Redis这种高性能的服务来说是致命的，所以Redis是面向快速执行场景的数据库。

## 2.2 字符串

字符串类型是Redis最基础的数据结构。首先键都是字符串类型，而且其他几种数据结构都是在字符串类型基础上构建的，所以字符串类型能为其他四种数据结构的学习奠定基础。

![](images/字符串数据结构.png)

### 2.2.1 命令

#### 常用命令

（1）批量设置值：

​	mset key value [key value ...]

```shell
127.0.0.1:6379> mset a 1 b 2 c 3 d 4
OK
```

（2）批量获取值：

​	mget key [key ...]

```shell
127.0.0.1:6379> mget a b c d
1) "1"
2) "2"
3) "3"
4) "4"
```

如果有些键不存在，那么它的值为nil（空），结果是按照传入键的顺序返回：

```shell
127.0.0.1:6379> mget a b c f
1) "1"
2) "2"
3) "3"
4) (nil)
```

批量操作命令可以有效提高开发效率，假如没有mget这样的命令，要执行n次get命令需要按照图2-8的方式来执行，具体耗时如下：

n 次 get 时间 = n 次网络时间 + n 次命令时间

![](images/n次get命令执行模型.png)

使用mget命令后，要执行n次get命令操作只需要按照图2-9的方式来完成，具体耗时如下：

n 次 get 时间 = 1 次网络时间 + n 次命令时间

![](images/一次mget命令执行模型.png)

Redis可以支撑每秒数万的读写操作，但是这指的是Redis服务端的处理能力，对于客户端来说，一次命令除了命令时间还是有网络时间，假设网络时间为1毫秒，命令时间为0.1毫秒（按照每秒处理1万条命令算），那么执
行1000次get命令和1次mget命令的区别如表2-1，因为Redis的处理能力已经足够高，对于开发人员来说，网络可能会成为性能的瓶颈。

| 操作                        | 时间                           |
| --------------------------- | ------------------------------ |
| 1000次get                   | 1000×1+1000×0.1=1100毫秒=1.1秒 |
| 1次mget（组装1000个键值对） | 1×1+1000×0.1=101毫秒=0.101秒   |

学会使用批量操作，有助于提高业务处理效率，但是要注意的是每次批量操作所发送的命令数不是无节制的，如果数量过多可能造成Redis阻塞或者网络拥塞。

![](images/字符串类型命令时间复杂度.png)

### 2.2.2 内部编码

字符串类型的内部编码有3种：

（1）int：8个字节的长整型。

（2）embstr：小于等于39个字节的字符串。

（3）raw：大于39个字节的字符串。

Redis会根据当前值的类型和长度决定使用哪种内部编码实现。

数字：

```shell
127.0.0.1:6379> set key 8653
OK
127.0.0.1:6379> object encoding key
"int"
```

短字符串：

```shell
# 小于等于 39 个字节的字符串： embstr
127.0.0.1:6379> set key "hello,world"
OK
127.0.0.1:6379> object encoding key
"embstr"
```

长字符串：

```shell
# 大于 39 个字节的字符串： raw
127.0.0.1:6379> set key "one string greater than 39 byte........."
OK
127.0.0.1:6379> object encoding key
"raw"
127.0.0.1:6379> strlen key
(integer) 40
```

### 2.2.3 典型应用场景

#### 1、缓存功能

下图是比较典型的缓存使用场景，其中Redis作为缓存层，MySQL作为存储层，绝大部分请求的数据都是从Redis中获取。由于Redis具有支撑高并发的特性，所以缓存通常能起到加速读写和降低后端压力的作用。

![](images/Redis+MySQL组成的缓存存储架构.png)

Redis没有命令空间，而且也没有对键名有强制要求（除了不能使用一些特殊字符）。但设计合理的键名，有利于防止键冲突和项目的可维护性，比较推荐的方式是使用“业务名：对象名：id：[属性]”作为键名（也可以不是分号）。例如MySQL的数据库名为vs，用户表名为user，那么对应的键可以用"vs：user：1"，"vs：user：1：name"来表示，如果当前Redis只被一个业务使用，甚至可以去掉“vs：”。如果键名比较长，例如“user：{uid}：friends：messages：{mid}”，可以在能描述键含义的前提下适当减少键的长度，例如变为“u：{uid}：fr：m：{mid}”，从而减少由于键过长的内存浪费。

#### 2、计数

许多应用都会使用Redis作为计数的基础工具，它可以实现快速计数、查询缓存的功能，同时数据可以异步落地到其他数据源。

#### 3、共享Session

下图所示，一个分布式Web服务将用户的Session信息（例如用户登录信息）保存在各自服务器中，这样会造成一个问题，出于负载均衡的考虑，分布式服务会将用户的访问均衡到不同服务器上，用户刷新一次访问可能会发现需要重新登录，这个问题是用户无法容忍的。

![](images/Session分散管理.png)

为了解决这个问题，可以使用Redis将用户的Session进行集中管理，如下图所示，在这种模式下只要保证Redis是高可用和扩展性的，每次用户更新或者查询登录信息都直接从Redis中集中获取。

![](images/Redis集中管理Session.png)

#### 3、限速

## 2.3 哈希

哈希类型是指键值本身又是一个键值对结构，形如value={{field1，value1}，...{fieldN，valueN}}，Redis键值对和哈希类型二者的关系可以用图2-14来表示。

![](images/字符串和哈希类型对比.png)

哈希类型中的映射关系叫作field-value，注意这里的value是指field对应的值，不是键对应的值。

### 2.3.1 命令

#### 哈希类型命令的时间复杂度

![](images/哈希类型命令的时间复杂度.png)

### 2.3.2 内部编码

哈希类型的内部编码有两种：

（1）ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）、同时所有值都小于hash-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。

（2）hashtable（哈希表）：当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，因为此时ziplist的读写效率会下降，而hashtable的读写时间复杂度为O（1）。

### 2.3.3 使用场景

相比于使用字符串序列化缓存用户信息，哈希类型变得更加直观，并且在更新操作上会更加便捷。

![](images\关系型数据库表保存用户信息.png)

![](images/使用哈希类型缓存用户信息.png)

可以将每个用户的id定义为键后缀，多对field-value对应每个用户的属性。

需要注意的是哈希类型和关系型数据库有两点不同之处：

（1）哈希类型是稀疏的，而关系型数据库是完全结构化的，例如哈希类型每个键可以有不同的field，而关系型数据库一旦添加新的列，所有行都要为其设置值（即使为NULL）。

（2）关系型数据库可以做复杂的关系查询，而Redis去模拟关系型复杂查询开发困难，维护成本高。



到目前为止，我们已经能够用三种方法缓存用户信息，下面给出三种方案的实现方法和优缺点分析。

（1）原生字符串类型：每个属性一个键。

​	1）优点：简单直观，每个属性都支持更新操作。

​	2）缺点：占用过多的键，内存占用量较大，同时用户信息内聚性比较差，所以此种方案一般不会在生产环境使用。

（2）序列化字符串类型：将用户信息序列化后用一个键保存。

​	1）优点：简化编程，如果合理的使用序列化可以提高内存的使用效率。

​	2）缺点：序列化和反序列化有一定的开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到Redis中。

（3）哈希类型：每个用户属性使用一对field-value，但是只用一个键保存。

​	1）优点：简单直观，如果使用合理可以减少内存空间的使用。

​	2）缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。

## 2.4 列表

列表（list）类型是用来存储多个有序的字符串列表中的每个字符串称为元素（element），一个列表最多可以存储2 32 -1个元素。在Redis中，可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。

![](images/列表两端插入和弹出操作.png)

![](images/子列表获取、删除等操作.png)

列表类型有两个特点：

（1）列表中的元素是有序的，这就意味着可以通过索引下标获取某个元素或者某个范围内的元素列表。

（2）列表中的元素可以是重复的。

![](images/列表中可以包含重复元素.png)

### 2.4.1 命令

![](images/列表的四种操作类型.png)

![](images/列表命令时间复杂度.png)

### 2.4.2 内部编码

列表类型的内部编码有两种：

（1）ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。

（2）ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。

注：Redis3.2版本提供了quicklist内部编码，简单地说它是以一个ziplist为节点的linkedlist，它结合了ziplist和linkedlist两者的优势，为列表类型提供了一种更为优秀的内部编码实现。

### 2.4.3 使用场景

#### 1、消息队列

Redis的lpush+brpop命令组合即可实现阻塞队列，生产者客户端使用lrpush从列表左侧插入元素，多个消费者客户端使用brpop命令阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。

![](images/Redis消息队列模型.png)

#### 2、文章列表

每个用户有属于自己的文章列表，现需要分页展示文章列表。此时可以考虑使用列表，因为列表不但是有序的，同时支持按照索引范围获取元素。

#### 使用场景口诀：

实际上列表的使用场景很多，在选择时可以参考以下口诀：

（1）lpush+lpop=Stack（栈）。

（2）lpush+rpop=Queue（队列）。

（3）lpsh+ltrim=Capped Collection（有限集合）。

（4）lpush+brpop=Message Queue（消息队列）。

## 2.5 集合

集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。

![](images/集合类型.png)

### 2.5.1 命令

![](images/集合常用命令时间复杂度.png)

### 2.5.2 内部编码

集合类型的内部编码有两种：

（1）intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。

（2）hashtable（哈希表）：当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。

### 2.5.3 使用场景

集合类型比较典型的使用场景是标签（tag）。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签，这些数据对于用户体验以及增强用户黏度比较重要。

## 2.6 有序集合

有序集合相对于哈希、列表、集合来说会有一点点陌生，但既然叫有序集合，那么它和集合必然有着联系，它保留了集合不能有重复成员的特性，但不同的是，有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个分数（score）作为排序的依据。

![](images/序集合.png)

注：有序集合中的元素不能重复，但是score可以重复，就和一个班里的同学学号不能重复，但是考试成绩可以相同。

![](images/给出了列表、集合和有序集合三者的异同点.png)

### 2.6.1 命令

